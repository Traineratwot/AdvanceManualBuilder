{"version":3,"names":[],"mappings":"","sources":["assets/projects/AdvanceManualBuilder/old/engine/workstation/js/libs/fitty.js"],"sourcesContent":["((w) => {\r\n\r\n  // no window, early exit\r\n  if (!w) return;\r\n\r\n  // node list to array helper method\r\n  const toArray = nl => [].slice.call(nl);\r\n\r\n  // states\r\n  const DrawState = {\r\n    IDLE: 0,\r\n    DIRTY_CONTENT: 1,\r\n    DIRTY_LAYOUT: 2,\r\n    DIRTY: 3\r\n  };\r\n\r\n  // all active fitty elements\r\n  let fitties = [];\r\n\r\n  // group all redraw calls till next frame, we cancel each frame request when a new one comes in. If no support for request animation frame, this is an empty function and supports for fitty stops.\r\n  let redrawFrame = null;\r\n  const requestRedraw = 'requestAnimationFrame' in w ? () => {\r\n      w.cancelAnimationFrame(redrawFrame);\r\n      redrawFrame = w.requestAnimationFrame(() => redraw(fitties.filter(f => f.dirty && f.active)));\r\n    } : () => {};\r\n\r\n\r\n  // sets all fitties to dirty so they are redrawn on the next redraw loop, then calls redraw\r\n  const redrawAll = (type) => () => {\r\n    fitties.forEach(f => f.dirty = type);\r\n    requestRedraw();\r\n  };\r\n\r\n\r\n  // redraws fitties so they nicely fit their parent container\r\n  const redraw = fitties => {\r\n\r\n    // getting info from the DOM at this point should not trigger a reflow, let's gather as much intel as possible before triggering a reflow\r\n\r\n    // check if styles of all fitties have been computed\r\n    fitties\r\n      .filter(f => !f.styleComputed)\r\n      .forEach(f => { f.styleComputed = computeStyle(f) });\r\n\r\n    // restyle elements that require pre-styling, this triggers a reflow, please try to prevent by adding CSS rules (see docs)\r\n    fitties\r\n      .filter(shouldPreStyle)\r\n      .forEach(applyStyle);\r\n\r\n    // we now determine which fitties should be redrawn\r\n    const fittiesToRedraw = fitties.filter(shouldRedraw);\r\n    \r\n    // we calculate final styles for these fitties\r\n    fittiesToRedraw.forEach(calculateStyles);\r\n\r\n    // now we apply the calculated styles from our previous loop\r\n    fittiesToRedraw.forEach(f => {\r\n      applyStyle(f);\r\n      markAsClean(f);\r\n    });\r\n\r\n    // now we dispatch events for all restyled fitties\r\n    fittiesToRedraw.forEach(dispatchFitEvent);\r\n  };\r\n\r\n  const markAsClean = f => f.dirty = DrawState.IDLE;\r\n\r\n  const calculateStyles = f => {\r\n\r\n    // get available width from parent node\r\n    f.availableWidth = f.element.parentNode.clientWidth;\r\n\r\n    // the space our target element uses\r\n    f.currentWidth = f.element.scrollWidth;\r\n\r\n    // remember current font size\r\n    f.previousFontSize = f.currentFontSize;\r\n\r\n    // let's calculate the new font size\r\n    f.currentFontSize = Math.min(\r\n      Math.max(\r\n        f.minSize,\r\n        (f.availableWidth / f.currentWidth) * f.previousFontSize\r\n      ),\r\n      f.maxSize\r\n    );\r\n\r\n    // if allows wrapping, only wrap when at minimum font size (otherwise would break container)\r\n    f.whiteSpace = f.multiLine && f.currentFontSize === f.minSize\r\n      ? 'normal'\r\n      : 'nowrap';\r\n\r\n  };\r\n\r\n  // should always redraw if is not dirty layout, if is dirty layout, only redraw if size has changed\r\n  const shouldRedraw = f => f.dirty !== DrawState.DIRTY_LAYOUT || (f.dirty === DrawState.DIRTY_LAYOUT && f.element.parentNode.clientWidth !== f.availableWidth);\r\n\r\n  // every fitty element is tested for invalid styles\r\n  const computeStyle = f => {\r\n\r\n    // get style properties\r\n    const style = w.getComputedStyle(f.element, null);\r\n\r\n    // get current font size in pixels (if we already calculated it, use the calculated version)\r\n    f.currentFontSize = parseInt(style.getPropertyValue('font-size'), 10);\r\n\r\n    // get display type and wrap mode\r\n    f.display = style.getPropertyValue('display');\r\n    f.whiteSpace = style.getPropertyValue('white-space');\r\n  };\r\n\r\n\r\n  // determines if this fitty requires initial styling, can be prevented by applying correct styles through CSS\r\n  const shouldPreStyle = f => {\r\n\r\n    let preStyle = false;\r\n\r\n    // if we already tested for prestyling we don't have to do it again\r\n    if (f.preStyleTestCompleted) return false;\r\n\r\n    // should have an inline style, if not, apply\r\n    if (!/inline-/.test(f.display)) {\r\n      preStyle = true;\r\n      f.display = 'inline-block';\r\n    }\r\n\r\n    // to correctly calculate dimensions the element should have whiteSpace set to nowrap\r\n    if (f.whiteSpace !== 'nowrap') {\r\n      preStyle = true;\r\n      f.whiteSpace = 'nowrap';\r\n    }\r\n\r\n    // we don't have to do this twice\r\n    f.preStyleTestCompleted = true;\r\n\r\n    return preStyle;\r\n  };\r\n\r\n\r\n  // apply styles to single fitty\r\n  const applyStyle = f => {\r\n\r\n    // remember original style, we need this to restore the fitty style when unsubscribing\r\n    if (!f.originalStyle) f.originalStyle = f.element.getAttribute('style') || '';\r\n\r\n    // set the new style to the original style plus the fitty styles\r\n    f.element.style.cssText = `${f.originalStyle};white-space:${f.whiteSpace};display:${f.display};font-size:${f.currentFontSize}px`;\r\n  };\r\n\r\n\r\n  // dispatch a fit event on a fitty\r\n  const dispatchFitEvent = f => {\r\n    f.element.dispatchEvent(new CustomEvent('fit', {\r\n      detail:{\r\n        oldValue: f.previousFontSize,\r\n        newValue: f.currentFontSize,\r\n        scaleFactor: f.currentFontSize / f.previousFontSize\r\n      }\r\n    }));\r\n  };\r\n\r\n\r\n  // fit method, marks the fitty as dirty and requests a redraw (this will also redraw any other fitty marked as dirty)\r\n  const fit = (f, type) => () => {\r\n    f.dirty = type;\r\n    if (!f.active) return;\r\n    requestRedraw();\r\n  };\r\n\r\n  const init = f => {\r\n\r\n    // should we observe DOM mutations\r\n    observeMutations(f);\r\n\r\n    // this is a new fitty so we need to validate if it's styles are in order\r\n    f.newbie = true;\r\n\r\n    // because it's a new fitty it should also be dirty, we want it to redraw on the first loop\r\n    f.dirty = true;\r\n\r\n    // we want to be able to update this fitty\r\n    fitties.push(f);\r\n  }\r\n\r\n  const destroy = f => () => {\r\n\r\n    // remove from fitties array\r\n    fitties = fitties.filter(_ => _.element !== f.element);\r\n\r\n    // stop observing DOM\r\n    if (f.observeMutations) f.observer.disconnect();\r\n\r\n    // reset font size to inherited size\r\n    f.element.style.cssText = f.originalStyle;\r\n  };\r\n\r\n  // add a new fitty, does not redraw said fitty\r\n  const subscribe = f => () => {\r\n    if (f.active) return;\r\n    f.active = true;\r\n    requestRedraw();\r\n  };\r\n\r\n  // remove an existing fitty\r\n  const unsubscribe = f => () => f.active = false;\r\n\r\n  const observeMutations = f => {\r\n\r\n    // no observing?\r\n    if (!f.observeMutations) return;\r\n\r\n    // start observing mutations\r\n    f.observer = new MutationObserver(fit(f, DrawState.DIRTY_CONTENT));\r\n\r\n    // start observing\r\n    f.observer.observe(\r\n      f.element,\r\n      f.observeMutations\r\n    );\r\n\r\n  };\r\n\r\n\r\n  // default mutation observer settings\r\n  const mutationObserverDefaultSetting = {\r\n    subtree: true,\r\n    childList: true,\r\n    characterData: true\r\n  };\r\n\r\n\r\n  // default fitty options\r\n  const defaultOptions = {\r\n    minSize: 16,\r\n    maxSize: 512,\r\n    multiLine: true,\r\n    observeMutations: 'MutationObserver' in w ? mutationObserverDefaultSetting : false\r\n  };\r\n\r\n\r\n  // array of elements in, fitty instances out\r\n  function fittyCreate(elements, options) {\r\n\r\n    // set options object\r\n    const fittyOptions = {\r\n\r\n      // expand default options\r\n      ...defaultOptions,\r\n\r\n      // override with custom options\r\n      ...options\r\n    };\r\n\r\n    // create fitties\r\n    const publicFitties = elements.map(element => {\r\n\r\n      // create fitty instance\r\n      const f = {\r\n\r\n        // expand defaults\r\n        ...fittyOptions,\r\n\r\n        // internal options for this fitty\r\n        element,\r\n        active: true\r\n      };\r\n\r\n      // initialise this fitty\r\n      init(f);\r\n\r\n      // expose API\r\n      return {\r\n        element,\r\n        fit: fit(f, DrawState.DIRTY),\r\n        unfreeze: subscribe(f),\r\n        freeze: unsubscribe(f),\r\n        unsubscribe: destroy(f)\r\n      };\r\n\r\n    });\r\n\r\n    // call redraw on newly initiated fitties\r\n    requestRedraw();\r\n\r\n    // expose fitties\r\n    return publicFitties;\r\n  }\r\n\r\n\r\n  // fitty creation function\r\n  function fitty(target, options = {}) {\r\n\r\n    // if target is a string\r\n    return typeof target === 'string' ?\r\n\r\n      // treat it as a querySelector\r\n      fittyCreate( toArray( document.querySelectorAll(target) ), options) :\r\n\r\n      // create single fitty\r\n      fittyCreate([target], options)[0];\r\n  }\r\n\r\n\r\n  // handles viewport changes, redraws all fitties, but only does so after a timeout\r\n  let resizeDebounce = null;\r\n  const onWindowResized = () => {\r\n    w.clearTimeout(resizeDebounce);\r\n    resizeDebounce = w.setTimeout(\r\n      redrawAll(DrawState.DIRTY_LAYOUT),\r\n      fitty.observeWindowDelay\r\n    );\r\n  };\r\n\r\n\r\n  // define observe window property, so when we set it to true or false events are automatically added and removed\r\n  const events = [ 'resize', 'orientationchange' ];\r\n  Object.defineProperty(fitty, 'observeWindow', {\r\n    set: enabled => {\r\n      const method = `${enabled ? 'add' : 'remove'}EventListener`;\r\n      events.forEach(e => {\r\n        w[method](e, onWindowResized);\r\n      });\r\n    }\r\n  });\r\n\r\n\r\n  // fitty global properties (by setting observeWindow to true the events above get added)\r\n  fitty.observeWindow = true;\r\n  fitty.observeWindowDelay = 100;\r\n\r\n\r\n  // public fit all method, will force redraw no matter what\r\n  fitty.fitAll = redrawAll(DrawState.DIRTY);\r\n\r\n\r\n  // export our fitty function, we don't want to keep it to our selves\r\n  return fitty;\r\n\r\n})(typeof window === 'undefined' ? null : window);\r\n//# sourceMappingURL=fitty.js.map\r\n"],"file":"fitty.js"}