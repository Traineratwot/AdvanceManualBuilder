{"version":3,"names":[],"mappings":"","sources":["assets/projects/AdvanceManualBuilder/old/engine/workstation/js/libs/jstree/src/jstree.search.js"],"sourcesContent":["/**\r\n * ### Search plugin\r\n *\r\n * Adds search functionality to jsTree.\r\n */\r\n/*globals jQuery, define, exports, require, document */\r\n(function (factory) {\r\n\t;\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine('jstree.search', ['jquery','jstree'], factory);\r\n\t}\r\n\telse if(typeof exports === 'object') {\r\n\t\tfactory(require('jquery'), require('jstree'));\r\n\t}\r\n\telse {\r\n\t\tfactory(jQuery, jQuery.jstree);\r\n\t}\r\n}(function ($, jstree, undefined) {\r\n\t;\r\n\r\n\tif($.jstree.plugins.search) { return; }\r\n\r\n\t/**\r\n\t * stores all defaults for the search plugin\r\n\t * @name $.jstree.defaults.search\r\n\t * @plugin search\r\n\t */\r\n\t$.jstree.defaults.search = {\r\n\t\t/**\r\n\t\t * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.\r\n\t\t *\r\n\t\t * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.\r\n\t\t * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to\r\n\t\t * @name $.jstree.defaults.search.ajax\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tajax : false,\r\n\t\t/**\r\n\t\t * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.\r\n\t\t * @name $.jstree.defaults.search.fuzzy\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tfuzzy : false,\r\n\t\t/**\r\n\t\t * Indicates if the search should be case sensitive. Default is `false`.\r\n\t\t * @name $.jstree.defaults.search.case_sensitive\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tcase_sensitive : false,\r\n\t\t/**\r\n\t\t * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).\r\n\t\t * This setting can be changed at runtime when calling the search method. Default is `false`.\r\n\t\t * @name $.jstree.defaults.search.show_only_matches\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tshow_only_matches : false,\r\n\t\t/**\r\n\t\t * Indicates if the children of matched element are shown (when show_only_matches is true)\r\n\t\t * This setting can be changed at runtime when calling the search method. Default is `false`.\r\n\t\t * @name $.jstree.defaults.search.show_only_matches_children\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tshow_only_matches_children : false,\r\n\t\t/**\r\n\t\t * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.\r\n\t\t * @name $.jstree.defaults.search.close_opened_onclear\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tclose_opened_onclear : true,\r\n\t\t/**\r\n\t\t * Indicates if only leaf nodes should be included in search results. Default is `false`.\r\n\t\t * @name $.jstree.defaults.search.search_leaves_only\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tsearch_leaves_only : false,\r\n\t\t/**\r\n\t\t * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).\r\n\t\t * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.\r\n\t\t * @name $.jstree.defaults.search.search_callback\r\n\t\t * @plugin search\r\n\t\t */\r\n\t\tsearch_callback : false\r\n\t};\r\n\r\n\t$.jstree.plugins.search = function (options, parent) {\r\n\t\tthis.bind = function () {\r\n\t\t\tparent.bind.call(this);\r\n\r\n\t\t\tthis._data.search.str = \"\";\r\n\t\t\tthis._data.search.dom = $();\r\n\t\t\tthis._data.search.res = [];\r\n\t\t\tthis._data.search.opn = [];\r\n\t\t\tthis._data.search.som = false;\r\n\t\t\tthis._data.search.smc = false;\r\n\t\t\tthis._data.search.hdn = [];\r\n\r\n\t\t\tthis.element\r\n\t\t\t\t.on(\"search.jstree\", $.proxy(function (e, data) {\r\n\t\t\t\t\t\tif(this._data.search.som && data.res.length) {\r\n\t\t\t\t\t\t\tvar m = this._model.data, i, j, p = [], k, l;\r\n\t\t\t\t\t\t\tfor(i = 0, j = data.res.length; i < j; i++) {\r\n\t\t\t\t\t\t\t\tif(m[data.res[i]] && !m[data.res[i]].state.hidden) {\r\n\t\t\t\t\t\t\t\t\tp.push(data.res[i]);\r\n\t\t\t\t\t\t\t\t\tp = p.concat(m[data.res[i]].parents);\r\n\t\t\t\t\t\t\t\t\tif(this._data.search.smc) {\r\n\t\t\t\t\t\t\t\t\t\tfor (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tp.push(m[data.res[i]].children_d[k]);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tp = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);\r\n\t\t\t\t\t\t\tthis._data.search.hdn = this.hide_all(true);\r\n\t\t\t\t\t\t\tthis.show_node(p, true);\r\n\t\t\t\t\t\t\tthis.redraw(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this))\r\n\t\t\t\t.on(\"clear_search.jstree\", $.proxy(function (e, data) {\r\n\t\t\t\t\t\tif(this._data.search.som && data.res.length) {\r\n\t\t\t\t\t\t\tthis.show_node(this._data.search.hdn, true);\r\n\t\t\t\t\t\t\tthis.redraw(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, this));\r\n\t\t};\r\n\t\t/**\r\n\t\t * used to search the tree nodes for a given string\r\n\t\t * @name search(str [, skip_async])\r\n\t\t * @param {String} str the search string\r\n\t\t * @param {Boolean} skip_async if set to true server will not be queried even if configured\r\n\t\t * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)\r\n\t\t * @param {mixed} inside an optional node to whose children to limit the search\r\n\t\t * @param {Boolean} append if set to true the results of this search are appended to the previous search\r\n\t\t * @plugin search\r\n\t\t * @trigger search.jstree\r\n\t\t */\r\n\t\tthis.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {\r\n\t\t\tif(str === false || $.trim(str.toString()) === \"\") {\r\n\t\t\t\treturn this.clear_search();\r\n\t\t\t}\r\n\t\t\tinside = this.get_node(inside);\r\n\t\t\tinside = inside && inside.id ? inside.id : null;\r\n\t\t\tstr = str.toString();\r\n\t\t\tvar s = this.settings.search,\r\n\t\t\t\ta = s.ajax ? s.ajax : false,\r\n\t\t\t\tm = this._model.data,\r\n\t\t\t\tf = null,\r\n\t\t\t\tr = [],\r\n\t\t\t\tp = [], i, j;\r\n\t\t\tif(this._data.search.res.length && !append) {\r\n\t\t\t\tthis.clear_search();\r\n\t\t\t}\r\n\t\t\tif(show_only_matches === undefined) {\r\n\t\t\t\tshow_only_matches = s.show_only_matches;\r\n\t\t\t}\r\n\t\t\tif(show_only_matches_children === undefined) {\r\n\t\t\t\tshow_only_matches_children = s.show_only_matches_children;\r\n\t\t\t}\r\n\t\t\tif(!skip_async && a !== false) {\r\n\t\t\t\tif($.isFunction(a)) {\r\n\t\t\t\t\treturn a.call(this, str, $.proxy(function (d) {\r\n\t\t\t\t\t\t\tif(d && d.d) { d = d.d; }\r\n\t\t\t\t\t\t\tthis._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\r\n\t\t\t\t\t\t\t\tthis.search(str, true, show_only_matches, inside, append, show_only_matches_children);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}, this), inside);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta = $.extend({}, a);\r\n\t\t\t\t\tif(!a.data) { a.data = {}; }\r\n\t\t\t\t\ta.data.str = str;\r\n\t\t\t\t\tif(inside) {\r\n\t\t\t\t\t\ta.data.inside = inside;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this._data.search.lastRequest) {\r\n\t\t\t\t\t\tthis._data.search.lastRequest.abort();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._data.search.lastRequest = $.ajax(a)\r\n\t\t\t\t\t\t.fail($.proxy(function () {\r\n\t\t\t\t\t\t\tthis._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };\r\n\t\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\r\n\t\t\t\t\t\t}, this))\r\n\t\t\t\t\t\t.done($.proxy(function (d) {\r\n\t\t\t\t\t\t\tif(d && d.d) { d = d.d; }\r\n\t\t\t\t\t\t\tthis._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\r\n\t\t\t\t\t\t\t\tthis.search(str, true, show_only_matches, inside, append, show_only_matches_children);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}, this));\r\n\t\t\t\t\treturn this._data.search.lastRequest;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!append) {\r\n\t\t\t\tthis._data.search.str = str;\r\n\t\t\t\tthis._data.search.dom = $();\r\n\t\t\t\tthis._data.search.res = [];\r\n\t\t\t\tthis._data.search.opn = [];\r\n\t\t\t\tthis._data.search.som = show_only_matches;\r\n\t\t\t\tthis._data.search.smc = show_only_matches_children;\r\n\t\t\t}\r\n\r\n\t\t\tf = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });\r\n\t\t\t$.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {\r\n\t\t\t\tvar v = m[i];\r\n\t\t\t\tif(v.text && !v.state.hidden && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) ) {\r\n\t\t\t\t\tr.push(i);\r\n\t\t\t\t\tp = p.concat(v.parents);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif(r.length) {\r\n\t\t\t\tp = $.vakata.array_unique(p);\r\n\t\t\t\tfor(i = 0, j = p.length; i < j; i++) {\r\n\t\t\t\t\tif(p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {\r\n\t\t\t\t\t\tthis._data.search.opn.push(p[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(!append) {\r\n\t\t\t\t\tthis._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\\\$&') : v.replace($.jstree.idregex,'\\\\$&'); }).join(', #')));\r\n\t\t\t\t\tthis._data.search.res = r;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\\\$&') : v.replace($.jstree.idregex,'\\\\$&'); }).join(', #'))));\r\n\t\t\t\t\tthis._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));\r\n\t\t\t\t}\r\n\t\t\t\tthis._data.search.dom.children(\".jstree-anchor\").addClass('jstree-search');\r\n\t\t\t}\r\n\t\t\t/**\r\n\t\t\t * triggered after search is complete\r\n\t\t\t * @event\r\n\t\t\t * @name search.jstree\r\n\t\t\t * @param {jQuery} nodes a jQuery collection of matching nodes\r\n\t\t\t * @param {String} str the search string\r\n\t\t\t * @param {Array} res a collection of objects represeing the matching nodes\r\n\t\t\t * @plugin search\r\n\t\t\t */\r\n\t\t\tthis.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });\r\n\t\t};\r\n\t\t/**\r\n\t\t * used to clear the last search (removes classes and shows all nodes if filtering is on)\r\n\t\t * @name clear_search()\r\n\t\t * @plugin search\r\n\t\t * @trigger clear_search.jstree\r\n\t\t */\r\n\t\tthis.clear_search = function () {\r\n\t\t\tif(this.settings.search.close_opened_onclear) {\r\n\t\t\t\tthis.close_node(this._data.search.opn, 0);\r\n\t\t\t}\r\n\t\t\t/**\r\n\t\t\t * triggered after search is complete\r\n\t\t\t * @event\r\n\t\t\t * @name clear_search.jstree\r\n\t\t\t * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)\r\n\t\t\t * @param {String} str the search string (the last search string)\r\n\t\t\t * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)\r\n\t\t\t * @plugin search\r\n\t\t\t */\r\n\t\t\tthis.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });\r\n\t\t\tif(this._data.search.res.length) {\r\n\t\t\t\tthis._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {\r\n\t\t\t\t\treturn \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\\\$&') : v.replace($.jstree.idregex,'\\\\$&');\r\n\t\t\t\t}).join(', #')));\r\n\t\t\t\tthis._data.search.dom.children(\".jstree-anchor\").removeClass(\"jstree-search\");\r\n\t\t\t}\r\n\t\t\tthis._data.search.str = \"\";\r\n\t\t\tthis._data.search.res = [];\r\n\t\t\tthis._data.search.opn = [];\r\n\t\t\tthis._data.search.dom = $();\r\n\t\t};\r\n\r\n\t\tthis.redraw_node = function(obj, deep, callback, force_render) {\r\n\t\t\tobj = parent.redraw_node.apply(this, arguments);\r\n\t\t\tif(obj) {\r\n\t\t\t\tif($.inArray(obj.id, this._data.search.res) !== -1) {\r\n\t\t\t\t\tvar i, j, tmp = null;\r\n\t\t\t\t\tfor(i = 0, j = obj.childNodes.length; i < j; i++) {\r\n\t\t\t\t\t\tif(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\r\n\t\t\t\t\t\t\ttmp = obj.childNodes[i];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(tmp) {\r\n\t\t\t\t\t\ttmp.className += ' jstree-search';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t};\r\n\t};\r\n\r\n\t// helpers\r\n\t(function ($) {\r\n\t\t// from http://kiro.me/projects/fuse.html\r\n\t\t$.vakata.search = function(pattern, txt, options) {\r\n\t\t\toptions = options || {};\r\n\t\t\toptions = $.extend({}, $.vakata.search.defaults, options);\r\n\t\t\tif(options.fuzzy !== false) {\r\n\t\t\t\toptions.fuzzy = true;\r\n\t\t\t}\r\n\t\t\tpattern = options.caseSensitive ? pattern : pattern.toLowerCase();\r\n\t\t\tvar MATCH_LOCATION\t= options.location,\r\n\t\t\t\tMATCH_DISTANCE\t= options.distance,\r\n\t\t\t\tMATCH_THRESHOLD\t= options.threshold,\r\n\t\t\t\tpatternLen = pattern.length,\r\n\t\t\t\tmatchmask, pattern_alphabet, match_bitapScore, search;\r\n\t\t\tif(patternLen > 32) {\r\n\t\t\t\toptions.fuzzy = false;\r\n\t\t\t}\r\n\t\t\tif(options.fuzzy) {\r\n\t\t\t\tmatchmask = 1 << (patternLen - 1);\r\n\t\t\t\tpattern_alphabet = (function () {\r\n\t\t\t\t\tvar mask = {},\r\n\t\t\t\t\t\ti = 0;\r\n\t\t\t\t\tfor (i = 0; i < patternLen; i++) {\r\n\t\t\t\t\t\tmask[pattern.charAt(i)] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (i = 0; i < patternLen; i++) {\r\n\t\t\t\t\t\tmask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn mask;\r\n\t\t\t\t}());\r\n\t\t\t\tmatch_bitapScore = function (e, x) {\r\n\t\t\t\t\tvar accuracy = e / patternLen,\r\n\t\t\t\t\t\tproximity = Math.abs(MATCH_LOCATION - x);\r\n\t\t\t\t\tif(!MATCH_DISTANCE) {\r\n\t\t\t\t\t\treturn proximity ? 1.0 : accuracy;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn accuracy + (proximity / MATCH_DISTANCE);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tsearch = function (text) {\r\n\t\t\t\ttext = options.caseSensitive ? text : text.toLowerCase();\r\n\t\t\t\tif(pattern === text || text.indexOf(pattern) !== -1) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tisMatch: true,\r\n\t\t\t\t\t\tscore: 0\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tif(!options.fuzzy) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tisMatch: false,\r\n\t\t\t\t\t\tscore: 1\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tvar i, j,\r\n\t\t\t\t\ttextLen = text.length,\r\n\t\t\t\t\tscoreThreshold = MATCH_THRESHOLD,\r\n\t\t\t\t\tbestLoc = text.indexOf(pattern, MATCH_LOCATION),\r\n\t\t\t\t\tbinMin, binMid,\r\n\t\t\t\t\tbinMax = patternLen + textLen,\r\n\t\t\t\t\tlastRd, start, finish, rd, charMatch,\r\n\t\t\t\t\tscore = 1,\r\n\t\t\t\t\tlocations = [];\r\n\t\t\t\tif (bestLoc !== -1) {\r\n\t\t\t\t\tscoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\r\n\t\t\t\t\tbestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);\r\n\t\t\t\t\tif (bestLoc !== -1) {\r\n\t\t\t\t\t\tscoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbestLoc = -1;\r\n\t\t\t\tfor (i = 0; i < patternLen; i++) {\r\n\t\t\t\t\tbinMin = 0;\r\n\t\t\t\t\tbinMid = binMax;\r\n\t\t\t\t\twhile (binMin < binMid) {\r\n\t\t\t\t\t\tif (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {\r\n\t\t\t\t\t\t\tbinMin = binMid;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbinMax = binMid;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbinMid = Math.floor((binMax - binMin) / 2 + binMin);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbinMax = binMid;\r\n\t\t\t\t\tstart = Math.max(1, MATCH_LOCATION - binMid + 1);\r\n\t\t\t\t\tfinish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;\r\n\t\t\t\t\trd = new Array(finish + 2);\r\n\t\t\t\t\trd[finish + 1] = (1 << i) - 1;\r\n\t\t\t\t\tfor (j = finish; j >= start; j--) {\r\n\t\t\t\t\t\tcharMatch = pattern_alphabet[text.charAt(j - 1)];\r\n\t\t\t\t\t\tif (i === 0) {\r\n\t\t\t\t\t\t\trd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\trd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (rd[j] & matchmask) {\r\n\t\t\t\t\t\t\tscore = match_bitapScore(i, j - 1);\r\n\t\t\t\t\t\t\tif (score <= scoreThreshold) {\r\n\t\t\t\t\t\t\t\tscoreThreshold = score;\r\n\t\t\t\t\t\t\t\tbestLoc = j - 1;\r\n\t\t\t\t\t\t\t\tlocations.push(bestLoc);\r\n\t\t\t\t\t\t\t\tif (bestLoc > MATCH_LOCATION) {\r\n\t\t\t\t\t\t\t\t\tstart = Math.max(1, 2 * MATCH_LOCATION - bestLoc);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastRd = rd;\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tisMatch: bestLoc >= 0,\r\n\t\t\t\t\tscore: score\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t\treturn txt === true ? { 'search' : search } : search(txt);\r\n\t\t};\r\n\t\t$.vakata.search.defaults = {\r\n\t\t\tlocation : 0,\r\n\t\t\tdistance : 100,\r\n\t\t\tthreshold : 0.6,\r\n\t\t\tfuzzy : false,\r\n\t\t\tcaseSensitive : false\r\n\t\t};\r\n\t}($));\r\n\r\n\t// include the search plugin by default\r\n\t// $.jstree.defaults.plugins.push(\"search\");\r\n}));\r\n\r\n//# sourceMappingURL=jstree.search.js.map\r\n"],"file":"jstree.search.js"}